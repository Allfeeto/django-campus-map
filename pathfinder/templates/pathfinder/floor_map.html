<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Floor {{ floor }}</title>

    <!-- Подключение Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .map-container {
            position: relative;
            width: 100%;
            max-width: 900px; /* Ограничиваем видимую область карты */
            height: 500px;     /* Ограничиваем высоту карты */
            overflow: hidden;  /* Отключаем стандартную прокрутку */
            border: 1px solid #ddd;
            margin: 0 auto;    /* Центрируем карту */
            user-select: none; /* Отключение выделения текста */
            touch-action: pan-x pan-y; /* Разрешаем прокрутку, но обработаем жесты вручную */
        }

        .map-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0; /* Устанавливаем точку масштабирования */
            transition: transform 0.1s ease-out; /* Плавное масштабирование */
        }

        .map-overlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2; /* Отображаем слой маршрута поверх карты */
        }
    </style>
</head>
<body class="bg-light">
    {% load static %}
    {% load form_filters %}

    <div class="container">
        <h1 class="text-center text-primary mb-4">Этаж {{ floor }}</h1>

        <!-- Форма для выбора начальной и конечной точки -->
        <form method="post" class="row g-3">
            {% csrf_token %}
            <div class="col-md-5">
                <label for="start" class="form-label">Начальная точка</label>
                {{ form.start|add_class:"form-select" }}
            </div>
            <div class="col-md-5">
                <label for="end" class="form-label">Конечная точка</label>
                {{ form.end|add_class:"form-select" }}
            </div>
            <div class="col-md-2 d-flex align-items-end">
                <button type="submit" class="btn btn-primary w-100">Построить маршрут</button>
            </div>
        </form>

        <!-- Карта с масштабированием -->
        <div class="map-container mt-4" id="map-container">
            <div class="map-wrapper" id="map-wrapper">
                <object type="image/svg+xml" data="{% static 'pathfinder/flour_1.svg' %}" width="4500" height="2500" alt="Floor {{ floor }}"></object>


                <!-- Слой маршрута -->
                <svg class="map-overlay" width="4500" height="2500" xmlns="http://www.w3.org/2000/svg">
                    <!-- Рёбра маршрута -->
                    {% for edge in path_edges %}
                    <line x1="{{ edge.from_node.x }}" y1="{{ edge.from_node.y }}"
                          x2="{{ edge.to_node.x }}" y2="{{ edge.to_node.y }}"
                          stroke="darkblue" stroke-width="4" />
                    {% endfor %}

                    <!-- Отображаем только начальный и конечный узлы -->
                    {% for node in nodes %}
                    <circle cx="{{ node.x }}" cy="{{ node.y }}" r="10" fill="darkblue" stroke="black" stroke-width="2">
                        <title>{{ node.name }}</title>
                    </circle>
                    {% endfor %}
                </svg>
            </div>
        </div>
    </div>

    <!-- Подключение Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Добавление масштабирования к центру курсора -->
    <script>
    const container = document.getElementById('map-container');
    const wrapper = document.getElementById('map-wrapper');
    let scale = 0.2; // Установить минимальный масштаб при загрузке
    let translateX = 0, translateY = 0; // Текущая позиция
    let isDragging = false;
    let startX, startY, touchStartX, touchStartY;

    // Получить размеры карты и контейнера
    const mapWidth = 4500; // Ширина карты (в пикселях)
    const mapHeight = 2500; // Высота карты (в пикселях)
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;

    // Применение начального масштаба
    function initializeTransform() {
        wrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    // Масштабирование с учётом центра курсора
    container.addEventListener('wheel', (e) => {
        e.preventDefault();

        const scaleAmount = 0.1;
        const oldScale = scale;

        // Новое значение масштаба
        if (e.deltaY < 0) {
            scale += scaleAmount; // Увеличение масштаба
        } else {
            scale = Math.max(0.2, scale - scaleAmount); // Минимальный масштаб
        }

        const rect = container.getBoundingClientRect();

        // Координаты курсора относительно контейнера
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Вычисление сдвига для центрирования курсора
        const offsetX = (mouseX - translateX) / oldScale;
        const offsetY = (mouseY - translateY) / oldScale;

        translateX = mouseX - offsetX * scale;
        translateY = mouseY - offsetY * scale;

        updateTransform();
    });

    // Ограничить координаты перемещения
    function clampPosition() {
        const scaledWidth = mapWidth * scale;
        const scaledHeight = mapHeight * scale;

        // Лимиты по горизонтали
        const minX = Math.min(0, containerWidth - scaledWidth);
        const maxX = 0;

        // Лимиты по вертикали
        const minY = Math.min(0, containerHeight - scaledHeight);
        const maxY = 0;

        translateX = Math.max(minX, Math.min(maxX, translateX));
        translateY = Math.max(minY, Math.min(maxY, translateY));
    }

    // Начало перемещения карты (мышь)
    container.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Отключаем выделение текста
        isDragging = true;
        startX = e.clientX - translateX;
        startY = e.clientY - translateY;
    });

    // Перемещение карты (мышь)
    container.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        translateX = e.clientX - startX;
        translateY = e.clientY - startY;
        clampPosition(); // Применить ограничения
        updateTransform();
    });

    // Завершение перемещения карты (мышь)
    container.addEventListener('mouseup', () => isDragging = false);
    container.addEventListener('mouseleave', () => isDragging = false);

    // Обработка касаний (тачскрин)
    container.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            // Одно касание — перемещение
            isDragging = true;
            touchStartX = e.touches[0].clientX - translateX;
            touchStartY = e.touches[0].clientY - translateY;
        }
    });
    
    
    
    
    
    
    let initialDistance = null;
    let initialCenter = null;
    
    // Рассчитать центр между двумя пальцами
    function getTouchCenter(touches) {
        const x = (touches[0].clientX + touches[1].clientX) / 2;
        const y = (touches[0].clientY + touches[1].clientY) / 2;
        return { x, y };
    }
    
    // Начало масштабирования
    container.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialDistance = Math.sqrt(dx * dx + dy * dy);
            initialCenter = getTouchCenter(e.touches); // Сохраняем начальный центр
        }
    });
    
    // Масштабирование
    container.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && initialDistance) {
            e.preventDefault();
    
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const currentDistance = Math.sqrt(dx * dx + dy * dy);
    
            // Новый масштаб
            const scaleChange = currentDistance / initialDistance;
            const newScale = Math.max(0.2, scale * scaleChange); // Минимальный масштаб
    
            // Центр между пальцами
            const currentCenter = getTouchCenter(e.touches);
    
            // Смещение карты
            const rect = container.getBoundingClientRect();
            const offsetX = (currentCenter.x - rect.left - translateX) / scale;
            const offsetY = (currentCenter.y - rect.top - translateY) / scale;
    
            // Пересчёт положения для сохранения центра
            translateX = currentCenter.x - rect.left - offsetX * newScale;
            translateY = currentCenter.y - rect.top - offsetY * newScale;
    
            scale = newScale;
            initialDistance = currentDistance; // Обновляем расстояние
            updateTransform();
        }
    });
    
    // Завершение масштабирования
    container.addEventListener('touchend', () => {
        if (initialDistance) {
            initialDistance = null;
            initialCenter = null;
        }
    });

    
    
    

    container.addEventListener('touchmove', (e) => {
        if (!isDragging || e.touches.length !== 1) return;
        translateX = e.touches[0].clientX - touchStartX;
        translateY = e.touches[0].clientY - touchStartY;
        clampPosition(); // Применить ограничения
        updateTransform();
    });

    container.addEventListener('touchend', () => isDragging = false);
    container.addEventListener('touchcancel', () => isDragging = false);

    // Обновление трансформации
    function updateTransform() {
        wrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }
    


    // Функция для центрирования изображения в контейнере
    function centerMap() {
        // Получаем размеры контейнера
        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;
    
        // Рассчитываем смещение для центрирования карты (с учётом масштаба)
        translateX = (containerWidth - mapWidth * scale) / 2;
        translateY = (containerHeight - mapHeight * scale) / 2;
    
        // Применяем трансформацию (сдвиг и масштаб)
        updateTransform();
    }
    
    // Обновление трансформации
    function updateTransform() {
        wrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }
    
    // Инициализация при загрузке страницы
    window.addEventListener('load', centerMap);
    window.addEventListener('resize', centerMap); // Центрируем карту при изменении размера окна

    

    // Инициализация карты
    initializeTransform();
</script>

</body>
</html>
